ASYNCH COURSE:
Introduction √† l'Asynchronisme en JavaScript
L'asynchronisme est un concept essentiel en JavaScript, surtout lorsque nous travaillons avec des op√©rations qui prennent du temps √† se terminer, comme des requ√™tes r√©seau ou des temporisations. Dans ce cours, nous allons explorer diff√©rentes fa√ßons de g√©rer l'asynchronisme : avec des callbacks, des promesses (Promise), et async/await.
Exemple de Code Synchrone
Commen√ßons par examiner du code simple et synchrone. Le code s'ex√©cute ligne par ligne, sans attendre qu'une op√©ration longue soit termin√©e.
js
Copier le code
console.log("üëã Hello World!");
console.log("T√¢che 1");
console.log("T√¢che 2");
console.log("T√¢che 3");

setTimeout(() => {
    console.log("Op√©ration termin√©e !");
}, 2000); // Op√©ration asynchrone, elle sera ex√©cut√©e apr√®s 2 secondes

console.log("T√¢che 4");

Explication
La fonction setTimeout est un exemple de fonction asynchrone. Cela signifie que le reste du programme continue de s'ex√©cuter pendant que setTimeout attend. Le message "Op√©ration termin√©e !" sera affich√© apr√®s les t√¢ches 1 √† 4, m√™me si la fonction setTimeout est appel√©e avant la t√¢che 4.
T√¢ches 1, 2, 3 et 4 sont ex√©cut√©es imm√©diatement, tandis que l'op√©ration asynchrone (setTimeout) prend 2 secondes avant de terminer.
Callbacks
Un callback est une fonction qui est pass√©e en argument √† une autre fonction et qui est ex√©cut√©e une fois que l'op√©ration asynchrone est termin√©e. Voici comment cela fonctionne avec une op√©ration simul√©e :
js
Copier le code
function operationAsynchrone_1(callback) {
    console.log("D√©but de l'op√©ration...");
    setTimeout(() => {
        console.log("Op√©ration_1 termin√©e !");
        callback();
    }, 2000); // Simule une op√©ration qui prend 2 secondes
}

function fin() {
    console.log("Je suis appel√© apr√®s l'op√©ration asynchrone.");
}

operationAsynchrone_1(fin); // Le callback est pass√© ici

Explication
La fonction operationAsynchrone_1 commence par afficher "D√©but de l'op√©ration...".
Apr√®s 2 secondes (gr√¢ce √† setTimeout), elle affiche "Op√©ration_1 termin√©e !" et appelle le callback (ici, la fonction fin).
La fonction fin affiche "Je suis appel√© apr√®s l'op√©ration asynchrone."
Les callbacks sont une fa√ßon classique de g√©rer l'asynchronisme, mais ils peuvent devenir difficiles √† suivre quand il y a plusieurs op√©rations asynchrones imbriqu√©es.
Les Promesses (Promise)
Les promesses sont une solution plus moderne pour g√©rer l'asynchronisme. Elles permettent de manipuler des op√©rations asynchrones de mani√®re plus propre, en utilisant resolve pour les succ√®s et reject pour les √©checs.
js
Copier le code
function operationAsynchrone_2() {
    return new Promise((resolve, reject) => {
        console.log("D√©but de l'op√©ration...");
        setTimeout(() => {
            const success = true; // Simule un succ√®s ou un √©chec
            if (success) {
                resolve("Op√©ration_2 r√©ussie !");
            } else {
                reject("Op√©ration √©chou√©e !");
            }
        }, 2000);
    });
}

Utilisation des Promesses
js
Copier le code
operationAsynchrone_2()
    .then((result) => console.log(result)) // G√©rer le succ√®s
    .catch((error) => console.log(error)); // G√©rer l'√©chec

Explication
operationAsynchrone_2 retourne une promesse.
Si l'op√©ration est un succ√®s (resolve), le message "Op√©ration_2 r√©ussie !" est affich√©.
Si l'op√©ration √©choue (reject), un message d'erreur est affich√©.
async / await
L'usage de async et await permet d'√©crire du code asynchrone d'une mani√®re plus lisible et s√©quentielle.
js
Copier le code
async function login() {
    try {
        const result = await operationAsynchrone(); // Attend que la promesse soit r√©solue
        console.log(result); // Affiche le r√©sultat
        // Appel d'autres fonctions....
    } catch (error) {
        console.log(error); // G√®re les erreurs
    }
}

Explication
La fonction login est marqu√©e avec le mot-cl√© async, ce qui permet d'utiliser await √† l'int√©rieur.
await attend que la promesse retourne une valeur avant de continuer l'ex√©cution du code. Si l'op√©ration r√©ussit, elle affiche le r√©sultat. Si elle √©choue, elle passe dans le bloc catch pour afficher l'erreur.
Requ√™tes HTTP Asynchrones avec fetch
Enfin, utilisons une requ√™te r√©seau asynchrone avec la fonction fetch :
js
Copier le code
async function fetchData() {
    try {
        const res = await fetch("https://jsonplaceholder.typicode.com/posts/1");
        console.log(res);

        const data = await res.json();
        console.table(data); // Affiche les donn√©es dans un tableau
    } catch (error) {
        console.log("Erreur lors de la r√©cup√©ration des donn√©es", error);
    }
}

fetchData();

Explication
fetchData est une fonction asynchrone qui utilise fetch pour r√©cup√©rer des donn√©es depuis un API simul√©e.
await attend que fetch termine, puis convertit la r√©ponse en JSON avec res.json().
Si une erreur survient (comme une mauvaise URL), elle est captur√©e dans le bloc catch.
Conclusion
Dans ce cours, nous avons couvert :
Les callbacks : une mani√®re de g√©rer les op√©rations asynchrones en JavaScript, en passant une fonction en param√®tre √† une autre fonction.
Les promesses : une approche plus √©l√©gante qui permet de cha√Æner les op√©rations asynchrones.
Le mot-cl√© async/await : qui simplifie la gestion des promesses en permettant d'√©crire du code asynchrone comme s'il √©tait synchrone.
Chacune de ces m√©thodes permet de g√©rer l'ex√©cution des op√©rations qui prennent du temps de mani√®re diff√©rente, mais compl√©mentaire. Vous √™tes maintenant en mesure de g√©rer des t√¢ches asynchrones dans vos projets JavaScript !


COURS N2
Qu'est-ce que le code asynchrone ?
Le code asynchrone permet d'ex√©cuter des t√¢ches sans bloquer l'ex√©cution du programme principal. C'est particuli√®rement utile pour des op√©rations qui prennent du temps, comme les requ√™tes r√©seau, les lectures de fichiers, ou les interactions avec des bases de donn√©es.

Les concepts cl√©s
Callbacks : Une fonction pass√©e comme argument √† une autre fonction, qui est ex√©cut√©e apr√®s que la fonction principale a termin√©.
Promises : Un objet repr√©sentant la r√©ussite ou l'√©chec d'une op√©ration asynchrone.
Async/Await : Une syntaxe plus lisible et plus facile √† utiliser pour g√©rer les promesses.
Callbacks
Un callback est une fonction qui est pass√©e comme argument √† une autre fonction et qui est ex√©cut√©e apr√®s que la fonction principale a termin√©.


function fetchData(callback) {
    setTimeout(() => {
        const data = "Some data";
        callback(data);
    }, 2000);
}

fetchData((data) => {
    console.log(data); // "Some data"
});
Promises
Une promesse est un objet qui repr√©sente la r√©ussite ou l'√©chec d'une op√©ration asynchrone. Elle a trois √©tats : pending, fulfilled, et rejected.


function fetchData() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            const data = "Some data";
            resolve(data);
        }, 2000);
    });
}

fetchData()
    .then((data) => {
        console.log(data); // "Some data"
    })
    .catch((error) => {
        console.error(error);
    });
Async/Await
async et await sont des mots-cl√©s qui permettent d'√©crire du code asynchrone de mani√®re plus lisible et plus facile √† comprendre.


async function fetchData() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            const data = "Some data";
            resolve(data);
        }, 2000);
    });
}

async function main() {
    try {
        const data = await fetchData();
        console.log(data); // "Some data"
    } catch (error) {
        console.error(error);
    }
}

main();
Comparaison
Callbacks : Utilis√©s dans les anciennes versions de JavaScript, peuvent devenir complexes et difficiles √† lire (probl√®me de "callback hell").
Promises : Plus lisibles que les callbacks, mais peuvent encore √™tre complexes pour les op√©rations imbriqu√©es.
Async/Await : La syntaxe la plus moderne et la plus lisible, permet d'√©crire du code asynchrone de mani√®re synchrone.
Conclusion
Le code asynchrone est essentiel pour des applications performantes et r√©actives. Les callbacks, les promesses et async/await sont des outils puissants pour g√©rer les op√©rations asynchrones. En fonction de vos besoins et de la complexit√© de votre code, vous pouvez choisir l'approche qui vous convient le mieux.


GPT 1
Pour aider des d√©butants √† comprendre les concepts d'async, await, et les callbacks dans JavaScript illustr√©s dans les images, voici deux exercices adapt√©s √† leur niveau :

Exercice 1 : Utiliser setTimeout et comprendre l'ex√©cution asynchrone
Cet exercice introduit le concept des callbacks et des op√©rations asynchrones de mani√®re simple.

Objectif : Simuler une op√©ration asynchrone avec setTimeout et utiliser une fonction de callback pour afficher un message une fois l'op√©ration termin√©e.

Cr√©e une fonction nomm√©e fetchData qui simule la r√©cup√©ration de donn√©es depuis un serveur.
Utilise setTimeout pour retarder l'ex√©cution de la fonction de 3 secondes.
Appelle une fonction de callback une fois la "r√©cup√©ration" termin√©e pour afficher un message : "Donn√©es r√©cup√©r√©es avec succ√®s !"
Code √† compl√©ter :

js
Copier le code
function fetchData(callback) {
  console.log("D√©but de la r√©cup√©ration des donn√©es...");
  setTimeout(() => {
    console.log("R√©cup√©ration des donn√©es termin√©e !");
    callback();
  }, 3000);
}

function fin() {
  console.log("Op√©ration asynchrone termin√©e !");
}

// Appel de la fonction avec le callback
fetchData(fin);
Explication : L'id√©e est de montrer que setTimeout ex√©cute du code apr√®s un certain d√©lai (asynchronisme). Le callback fin() sera ex√©cut√© une fois que fetchData() a termin√© son op√©ration asynchrone.

Exercice 2 : Utiliser async et await avec une requ√™te HTTP simul√©e
Cet exercice introduit les promesses et async/await en simulant une requ√™te pour r√©cup√©rer des donn√©es depuis une API.

Objectif : Cr√©er une fonction asynchrone qui utilise fetch pour r√©cup√©rer des donn√©es depuis une API simul√©e.

Cr√©e une fonction asynchrone getData.
Utilise fetch pour r√©cup√©rer les donn√©es depuis un faux endpoint (https://jsonplaceholder.typicode.com/posts/1).
Utilise await pour attendre la r√©ponse, et console.log les donn√©es r√©cup√©r√©es.
Code √† compl√©ter :

js
Copier le code
async function getData() {
  try {
    console.log("R√©cup√©ration des donn√©es...");
    const response = await fetch('https://jsonplaceholder.typicode.com/posts/1');
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.log("Erreur lors de la r√©cup√©ration des donn√©es : ", error);
  }
}

getData();
Explication : Cet exercice montre comment await attend que la promesse retourn√©e par fetch soit r√©solue avant de continuer l'ex√©cution du code, simplifiant ainsi la gestion du code asynchrone.

Ces deux exercices permettent aux d√©butants de manipuler des op√©rations asynchrones en utilisant √† la fois les callbacks et async/await, leur offrant une meilleure compr√©hension des bases de l'asynchronisme en JavaScript.
